Remove["Global`*"];

(*Sigma Matrix Setup*)
\[Sigma]1 = {{0, 1}, {1, 0}};
\[Sigma]2 = {{0, -I}, {I, 0}};
\[Sigma]3 = {{1, 0}, {0, -1}};
I2 = IdentityMatrix[2];

\[Sigma]Up[0] = KroneckerProduct[I2, I2, I2, I2];
\[Sigma]Up[1] = 
  KroneckerProduct[\[Sigma]2, \[Sigma]2, \[Sigma]2, \[Sigma]2];
\[Sigma]Up[2] = 
  KroneckerProduct[\[Sigma]2, \[Sigma]2, I2, \[Sigma]1];
\[Sigma]Up[3] = 
  KroneckerProduct[\[Sigma]2, \[Sigma]2, I2, \[Sigma]3];
\[Sigma]Up[4] = 
  KroneckerProduct[\[Sigma]2, \[Sigma]1, \[Sigma]2, I2];
\[Sigma]Up[5] = 
  KroneckerProduct[\[Sigma]2, \[Sigma]3, \[Sigma]2, I2];
\[Sigma]Up[6] = 
  KroneckerProduct[\[Sigma]2, I2, \[Sigma]1, \[Sigma]2];
\[Sigma]Up[7] = 
  KroneckerProduct[\[Sigma]2, I2, \[Sigma]3, \[Sigma]2];
\[Sigma]Up[8] = KroneckerProduct[\[Sigma]1, I2, I2, I2];
\[Sigma]Up[9] = KroneckerProduct[\[Sigma]3, I2, I2, I2];

\[Eta]sign[\[Mu]_Integer] := If[\[Mu] == 0, -1, 1];
\[Sigma][\[Mu]_Integer] := \[Eta]sign[\[Mu]] \[Sigma]Up[\[Mu]];

SigmaTildeUp[\[Mu]_Integer] := \[Eta]sign[\[Mu]] \[Sigma]Up[\[Mu]];
SigmaTilde[\[Mu]_Integer] := \[Eta]sign[\[Mu]] SigmaTildeUp[\[Mu]];

Sig2Up[\[Mu]_Integer, \[Nu]_Integer] := 
  1/2 (\[Sigma]Up[\[Mu]] . SigmaTildeUp[\[Nu]] - \[Sigma]Up[\[Nu]] . 
      SigmaTildeUp[\[Mu]]);

Sig2[\[Mu]_Integer, \[Nu]_Integer] := \[Eta]sign[\[Mu]] \[Eta]sign[\
\[Nu]] Sig2Up[\[Mu], \[Nu]];

TildeSig2Up[\[Mu]_Integer, \[Nu]_Integer] := 
  1/2 (SigmaTildeUp[\[Mu]] . \[Sigma]Up[\[Nu]] - 
     SigmaTildeUp[\[Nu]] . \[Sigma]Up[\[Mu]]);

Sig3Up[\[Mu]_Integer, \[Nu]_Integer, \[Rho]_Integer] := 
  Module[{perms}, (1/6) Total@
     Map[With[{p = #}, 
        Signature[
          p]*(\[Sigma]Up[p[[1]]] . 
           SigmaTildeUp[p[[2]]] . \[Sigma]Up[p[[3]]])] &, 
      Permutations[{\[Mu], \[Nu], \[Rho]}]]];

Sig3UpT[\[Mu]_Integer, \[Nu]_Integer, \[Rho]_Integer] := 
  Module[{perms}, (1/6) Total@
     Map[With[{p = #}, 
        Signature[
          p]*(SigmaTildeUp[p[[1]]] . \[Sigma]Up[p[[2]]] . 
           SigmaTildeUp[p[[3]]])] &, 
      Permutations[{\[Mu], \[Nu], \[Rho]}]]];

MixedLeft[\[Mu]_Integer, \[Nu]_Integer, \[Rho]_Integer, \
\[Xi]_Integer] := SigmaTilde[\[Mu]] . Sig3Up[\[Nu], \[Rho], \[Xi]];
MixedRight[\[Nu]_Integer, \[Rho]_Integer, \[Xi]_Integer, \
\[Mu]_Integer] := Sig3UpT[\[Nu], \[Rho], \[Xi]] . \[Sigma][\[Mu]];

(* =======================Gauge-fix& ORDERING==================*)
(*drop every h_{0\[Nu]} and B_{0\[Nu]};then order with h_{11} first*)
HPairsAll = 
  Flatten[Table[{\[Mu], \[Nu]}, {\[Mu], 0, 9}, {\[Nu], \[Mu], 9}], 
   1];    (*55*)
BPairsAll = 
  Flatten[Table[{\[Mu], \[Nu]}, {\[Mu], 0, 9}, {\[Nu], \[Mu] + 1, 9}],
    1]; (*45*)

HPairsGF = 
  Select[HPairsAll, #[[1]] =!= 0 &];  (*remove \[Mu]=0\[RightArrow]45*)
BPairsGF = 
  Select[BPairsAll, #[[1]] =!= 0 &];  (*remove \[Mu]=0\[RightArrow]36*)

(*custom order:H starts with {1,1} on top,then the rest lexicographic*)
HOrder = Prepend[DeleteCases[HPairsGF, {1, 1}], {1, 1}];
BOrder = 
  BPairsGF;  (*default lexicographic;edit here if you want a custom \
B-order*)

(*indexing maps for the BOSONIC columns (and L-rows) in this new \
order*)
HIndex = 
  AssociationThread[
   HOrder -> Range[Length[HOrder]]];            (*1..Length[HOrder]*)
BIndex = 
  AssociationThread[
   BOrder -> Range[Length[BOrder]]];            (*1..Length[BOrder]*)

(*single place to set the field redefinition:\[Beta]=betaScale*B*)
betaScale = 1;

(*helpers that mutate the target row/col*)
SetAttributes[addH, HoldFirst];
addH[row_, key_List, val_] := 
  If[KeyExistsQ[HIndex, key], row[[HIndex[key]]] += val];

SetAttributes[addB, HoldFirst];
addB[row_, key_List, val_] := 
  If[KeyExistsQ[BIndex, key], 
   row[[Length[HOrder] + BIndex[key]]] += val];

colPhi = Length[HOrder] + Length[BOrder] + 1;  (* =45+36+1=82*)

(* =======================Fermion indexing (\[Psi] then \[Chi])============*)
spinorCount = 16;
psiRow[\[Mu]_Integer, b_Integer] := \[Mu]*spinorCount + b;  (*1..160*)
chiRow[b_Integer] := 10*spinorCount + b; (*161..176*)

colPsi[\[Mu]_Integer, b_Integer] := psiRow[\[Mu], b];
colChi[b_Integer] := chiRow[b];

(* =======================R[a]:bosons->fermions===============*)
rowForPsi[\[Mu]_Integer, dotb_Integer, a_Integer] := 
  Module[{row = ConstantArray[0, colPhi], coeff, coeffB, 
    coeffA, \[Rho], \[Xi], keyH, keyB, 
    signB},(*1. h_{\rho\mu} term:-(1/2)\t
   ilde\sigma^{0\rho} \[PartialD]_0 h_{\rho\mu}*)
   Do[coeff = -(1/2)*TildeSig2Up[0, \[Rho]][[dotb, a]];
    keyH = Sort[{\[Rho], \[Mu]}];(*h is symmetric,so Sort is fine*)
    addH[row, keyH, coeff], {\[Rho], 0, 9}];
   (*2. B_{\rho\mu} term:-(1/2)\t
   ilde\sigma^{0\rho} \[PartialD]_0 B_{\rho\mu}*)
   Do[If[\[Rho] =!= \[Mu], 
     coeffB = -(1/2)*TildeSig2Up[0, \[Rho]][[dotb, a]];
     (*B is antisymmetric:choose canonical pair and include sign*)
     If[\[Rho] < \[Mu], keyB = {\[Rho], \[Mu]};
      signB = +1, keyB = {\[Mu], \[Rho]};
      signB = -1];
     (*betaScale kept here exactly as before*)
     addB[row, keyB, betaScale*signB*coeffB];], {\[Rho], 0, 9}];
   (*3. A_[3] term:+(i/16)(\tilde\sigma_\mu\sigma^{[3]}) A_[
   3] with A_{0\rho\xi}=(1/3) \[PartialD]_0 B_{\rho\xi} and Sig3Up[
   0,\[Rho],\[Xi]] carrying the 1/6,gives+(1/8)*MixedLeft[\[Mu],
   0,\[Rho],\[Xi]].*)
   Do[keyB = {\[Rho], \[Xi]};(*here \[Rho]<\[Xi],
    so this is already canonical*)
    coeffA = (1/16)*MixedLeft[\[Mu], 0, \[Rho], \[Xi]][[dotb, a]];
    addB[row, keyB, betaScale*coeffA];, {\[Rho], 0, 
     9}, {\[Xi], \[Rho] + 1, 9}];
   row];


rowForChi[b_Integer, a_Integer] := 
  Module[{row = ConstantArray[0, colPhi], \[Rho], \[Xi], keyB}, 
   row[[colPhi]] += (1/Sqrt[8])*\[Sigma]Up[0][[b, a]];
   Do[keyB = {\[Rho], \[Xi]};
    addB[row, keyB, 
     betaScale*(-(1/8))*Sig3Up[0, \[Rho], \[Xi]][[b, a]]];, {\[Rho], 
     0, 9}, {\[Xi], \[Rho] + 1, 9}];
   row];

R[a_Integer] := 
  Module[{psiBlock, chiBlock}, 
   psiBlock = 
    ArrayReshape[
     Flatten[Table[
       rowForPsi[\[Mu], dotb, a], {\[Mu], 0, 9}, {dotb, 1, 16}], 
      1], {10*16, colPhi}];(*\[Psi] rows first:160\[Times]82*)
   chiBlock = Table[rowForChi[b, a], {b, 1, 16}];(*\[Chi] rows:
   16\[Times]82*)
   Join[psiBlock, 
    chiBlock]                                      (*176\[Times]82*)];

(* =======================L[a]:fermions->bosons===============*)
coeffRow[\[Mu]_Integer, a_Integer] := \[Sigma][\[Mu]][[a, All]];
coeffRow2[\[Mu]_Integer, \[Nu]_Integer, a_Integer] := 
  Sig2[\[Mu], \[Nu]][[a, All]];

DcoeffsPsi\[Mu]\[Nu][\[Mu]_Integer, \[Nu]_Integer, a_Integer] := 
  Module[{c\[Mu] = coeffRow[\[Mu], a], c\[Nu] = coeffRow[\[Nu], a]}, 
   Table[{b, c\[Mu][[b]], c\[Nu][[b]]}, {b, 1, 16}]];

DcoeffsChi\[Mu]\[Nu][\[Mu]_Integer, \[Nu]_Integer, a_Integer] := 
  Module[{c = coeffRow2[\[Mu], \[Nu], a]}, 
   Table[{b, c[[b]]}, {b, 1, 16}]];

rowForH[\[Mu]_Integer, \[Nu]_Integer, a_Integer] := 
  Module[{row = ConstantArray[0, 176], psiTrip, b, c\[Mu], c\[Nu]}, 
   psiTrip = DcoeffsPsi\[Mu]\[Nu][\[Mu], \[Nu], a];
   Do[{b, c\[Mu], c\[Nu]} = t;
    If[c\[Mu] =!= 0, row[[colPsi[\[Nu], b]]] += c\[Mu]];
    If[c\[Nu] =!= 0, row[[colPsi[\[Mu], b]]] += c\[Nu]];, {t, 
     psiTrip}];
   row];

rowForB[\[Mu]_Integer, \[Nu]_Integer, a_Integer] := 
  Module[{row = ConstantArray[0, 176], psiTrip, chiTrip, b, c\[Mu], 
    c\[Nu], coeff}, psiTrip = DcoeffsPsi\[Mu]\[Nu][\[Mu], \[Nu], a];
   chiTrip = DcoeffsChi\[Mu]\[Nu][\[Mu], \[Nu], a];
   Do[{b, c\[Mu], c\[Nu]} = t;
    If[c\[Mu] =!= 0, row[[colPsi[\[Nu], b]]] += c\[Mu]];
    If[c\[Nu] =!= 0, row[[colPsi[\[Mu], b]]] += -c\[Nu]];, {t, 
     psiTrip}];
   Do[{b, coeff} = t;
    If[coeff =!= 0, row[[colChi[b]]] += coeff];, {t, chiTrip}];
   betaScale*row   (*because \[Beta]=betaScale*B*)];

HMatrix[a_Integer] := (rowForH @@@ (Append[#, a] & /@ 
      HOrder));   (*H-rows in new order*)
BMatrix[a_Integer] := (rowForB @@@ (Append[#, a] & /@ 
      BOrder));   (*then B-rows*)
PhiRowVector[a_Integer] := 
  Module[{row = ConstantArray[0, 176]}, row[[colChi[a]]] = Sqrt[8]; 
   row];

L[a_Integer] := 
  Join[HMatrix[a], 
   BMatrix[a], {PhiRowVector[
     a]}];  (*rows:H(11 first),B,\[CapitalPhi]*)



(*Insert Commands Below*)
